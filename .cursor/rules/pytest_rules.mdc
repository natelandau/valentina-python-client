---
description: Standards for writing Python tests using pytest
globs: tests/**/*.py
alwaysApply: false
---
## Standards for writing Python tests using pytest

Always follow these rules and standards for writing Python tests.

-  Review existing fixtures and reuse them if possible
-  For tests, write single sentence docstrings in imperative voice starting with the word "Verify"
-  Structure test body with given/when/then comments
-  Use pytest-mock plugin. Do not use unittest.
-  Include unit and integration tests.
-  Use fixture factories to create reusable test data.
-  Use fixtures for setup and teardown: Fixtures help manage test dependencies and ensure a clean test environment.
-  Avoid creating too many fixtures, especially for simple data.  Use direct data definition in the test if it's not reused.
-  Use `@pytest.mark.parametrize` to run the same test with different inputs and expected outputs, reducing code duplication.
-  Ensure tests are stateless and independent to avoid unexpected side effects. Each test should set up its own data and clean up after itself.
-  Use the `mocker` fixture provided by the `pytest-mock` plugin for mocking and stubbing.
-  Mock external dependencies, such as databases or APIs, to isolate your tests and prevent them from relying on external resources.
-  Use `autospec=True` when mocking to ensure that your mocks have the same API as the original objects. This helps prevent errors caused by incorrect mock implementations.

### Example of good tests

```python
@pytest.fixture
def user_factory():
    def create_user(username, email):
        return {"username": username, "email": email}
    return create_user

def test_backup_file_creates_backup(tmp_path, mocker, user_factory) -> None:
    """Verify creating backups file with .bak extension."""
    # Given a constant return from module.function
    mock_function = mocker.patch('module.function', autospec=True)
    mock_function.return_value = 'mocked'

    # Given a user
    user = user_factory("testuser", "test@example.com")
    assert user["username"] == "testuser"

    # Given: A test file exists
    file = tmp_path / "test.txt"
    file.write_text("test")

    # When: Creating a backup
    backup_file(file)

    # Then: Backup file exists and original is moved
    expected_backup = file.parent / (file.name + ".bak")
    assert expected_backup.exists()
    assert not file.exists()
```
